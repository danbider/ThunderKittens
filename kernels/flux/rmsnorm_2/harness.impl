#include <iostream>
#include <string>
#include <fstream>

#define B 1
#define H 24    
#define D 3072  
#define IMG_D 4080  
#define TXT_D 512
#define MULT_D 6
#define HEAD_D 128  

#define CudaCheckError()    __cudaCheckError( __FILE__, __LINE__ )
inline void __cudaCheckError( const char *file, const int line ) {
    cudaError err = cudaGetLastError();
    if ( cudaSuccess != err )
    {
        fprintf( stderr, "cudaCheckError() failed at %s:%i : %s\n",
                 file, line, cudaGetErrorString( err ) );
        exit( -1 );
    }
    // More careful checking. However, this will affect performance.
    // Comment away if needed.
    err = cudaDeviceSynchronize();
    if( cudaSuccess != err )
    {
        fprintf( stderr, "cudaCheckError() with sync failed at %s:%i : %s\n",
                 file, line, cudaGetErrorString( err ) );
        exit( -1 );
    }
}


int main(int argc, char **argv) {
    std::cout << "Entered main!" << std::endl;

    // Outputs
    constexpr int TOTAL_ELEMENTS_IMG_Q = B*H*IMG_D*HEAD_D;
    constexpr int TOTAL_UNIQUE_ELEMENTS_IMG_Q = H*IMG_D*HEAD_D;
    float *img_q_ref  = new float[TOTAL_UNIQUE_ELEMENTS_IMG_Q];
    float *img_q  = new float[TOTAL_ELEMENTS_IMG_Q]; // to store the output
    float *rms_in_img_q_ref  = new float[TOTAL_UNIQUE_ELEMENTS_IMG_Q];

    std::cout << "TOTAL_UNIQUE_ELEMENTS_IMG_Q=" << TOTAL_UNIQUE_ELEMENTS_IMG_Q << std::endl;
    
    constexpr int TOTAL_UNIQUE_ELEMENTS_RMS_Q_SCALE = HEAD_D;
    float *rms_q_scale  = new float[TOTAL_UNIQUE_ELEMENTS_RMS_Q_SCALE];

    if(argc > 1) {
        std::ifstream infile(argv[1]);

        printf("Loading from %s\n", argv[1]);
        std::cout << "Starting to enter!" << std::endl;

        for(int i = 0; i < TOTAL_UNIQUE_ELEMENTS_RMS_Q_SCALE; i++) {  
            infile >> rms_q_scale[i];  
            // if (i < 3 ) { std::cout << "2: " << rms_q_scale[i] << std::endl; }
        }
        for(int i = 0; i < TOTAL_UNIQUE_ELEMENTS_IMG_Q; i++) {  
            infile >> rms_in_img_q_ref[i];  
            // if (i < 3 ) { std::cout << "1: " << rms_in_img_q_ref[i] << std::endl; }
        }
        for(int i = 0; i < TOTAL_UNIQUE_ELEMENTS_IMG_Q; i++) {  
            infile >> img_q_ref[i];  
            // if (i < 3 ) { std::cout << "3: " << img_q_ref[i] << std::endl; }
        }
        std::cout << "Finished loading file from " << argv[1] << "!" << std::endl;
    }

    // RMS Inputs & Outputs
    bf16 *rms_in_img_q_bf = new bf16[TOTAL_ELEMENTS_IMG_Q];
    bf16 *rms_q_scale_bf = new bf16[TOTAL_UNIQUE_ELEMENTS_RMS_Q_SCALE];
    for(int i = 0; i < TOTAL_ELEMENTS_IMG_Q; i++) {
        rms_in_img_q_bf[i] = __float2bfloat16(rms_in_img_q_ref[i % TOTAL_UNIQUE_ELEMENTS_IMG_Q]);
        // if (i < 3) { std::cout << rms_in_img_q_ref[i % TOTAL_UNIQUE_ELEMENTS_IMG_Q] << std::endl; }
    }
    for(int i = 0; i < TOTAL_UNIQUE_ELEMENTS_RMS_Q_SCALE; i++) {
        rms_q_scale_bf[i] = __float2bfloat16(rms_q_scale[i % TOTAL_UNIQUE_ELEMENTS_RMS_Q_SCALE]);
        // if (i < 3) { std::cout << rms_q_scale[i % TOTAL_UNIQUE_ELEMENTS_RMS_Q_SCALE] << std::endl; }
    }
    bf16 *d_rms_in_img_q, *d_rms_q_scale;
    cudaMalloc(&d_rms_in_img_q, TOTAL_ELEMENTS_IMG_Q * sizeof(bf16));
    cudaMemcpy(d_rms_in_img_q, rms_in_img_q_bf, TOTAL_ELEMENTS_IMG_Q * sizeof(bf16), cudaMemcpyHostToDevice);
    cudaMalloc(&d_rms_q_scale, TOTAL_UNIQUE_ELEMENTS_RMS_Q_SCALE * sizeof(bf16));
    cudaMemcpy(d_rms_q_scale, rms_q_scale_bf, TOTAL_UNIQUE_ELEMENTS_RMS_Q_SCALE * sizeof(bf16), cudaMemcpyHostToDevice);

    bf16 *img_q_bf  = new bf16[TOTAL_ELEMENTS_IMG_Q];
    bf16 *d_img_q;
    cudaMalloc(&d_img_q, TOTAL_ELEMENTS_IMG_Q * sizeof(bf16));
    cudaMemcpy(d_img_q, img_q_bf, TOTAL_ELEMENTS_IMG_Q * sizeof(bf16), cudaMemcpyHostToDevice);
  
    // kernel rms norm
    unsigned long mem_size = 8000; // have the flag tell us
    cudaDeviceSynchronize();
    CudaCheckError();
    cudaFuncSetAttribute(
        flux_rmsnorm,
        cudaFuncAttributeMaxDynamicSharedMemorySize,
        mem_size
    );
    CudaCheckError();
    std::cout << "Starting kernel\n";
    const auto start = std::chrono::high_resolution_clock::now();
    flux_rmsnorm<<<B*H,NUM_THREADS_NORM,mem_size>>>(
        d_rms_in_img_q, d_rms_q_scale, d_img_q
    );  
    cudaDeviceSynchronize();
    const auto finish = std::chrono::high_resolution_clock::now();
    CudaCheckError();
    std::cout << "Finished kernel\n";
    
    // check correctness
    cudaMemcpy(img_q_bf, d_img_q, TOTAL_ELEMENTS_IMG_Q * sizeof(bf16), cudaMemcpyDeviceToHost);
    for(int i = 0; i < TOTAL_ELEMENTS_IMG_Q; i++) { img_q[i] = __bfloat162float(img_q_bf[i]); }

    bool good = true;
    std::ofstream img_q_ref_file("printouts/img_q_ref.txt");
    std::ofstream img_q_file("printouts/img_q.txt");
    std::ofstream img_q_diff_file("printouts/img_q_diff.txt");
    std::cout << "Total elements: " << TOTAL_ELEMENTS_IMG_Q << std::endl;
    std::cout << "Total unique elements: " << TOTAL_UNIQUE_ELEMENTS_IMG_Q << std::endl;

    for(int i = 0; i < TOTAL_ELEMENTS_IMG_Q; i++) {
        float diff = img_q[i] - img_q_ref[i % TOTAL_UNIQUE_ELEMENTS_IMG_Q];
        if(i < 1000) { // TOTAL_UNIQUE_ELEMENTS_IMG_Q
            img_q_ref_file << img_q_ref[i % TOTAL_UNIQUE_ELEMENTS_IMG_Q] << ' ';
            img_q_file << img_q[i] << ' ';
            img_q_diff_file << diff << ' ';
        }
        if(abs(diff) > 0.1 || isnan(diff)) {
            good = false;
        }
    }
    if(good) std::cout << "Correct out :)\n";
    else std::cout << "Incorrect out :(\n";

    std::cout << "Average execution time: " << std::chrono::duration_cast<std::chrono::microseconds>(finish - start).count() << " us" << std::endl;

    cudaFree(d_img_q);
    cudaFree(d_rms_in_img_q);
    cudaFree(d_rms_q_scale);
    delete[] img_q_ref, img_q, rms_in_img_q_ref;
    return 0;
}



