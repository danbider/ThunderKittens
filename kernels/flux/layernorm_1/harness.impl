#include <iostream>
#include <string>
#include <fstream>

#define B 1
#define H 24    
#define D 3072  
#define IMG_D 4080  
#define TXT_D 512
#define MULT_D 6
#define HEAD_D 128  

#define test_with_intermediates 1

#define CudaCheckError()    __cudaCheckError( __FILE__, __LINE__ )
inline void __cudaCheckError( const char *file, const int line ) {
    cudaError err = cudaGetLastError();
    if ( cudaSuccess != err )
    {
        fprintf( stderr, "cudaCheckError() failed at %s:%i : %s\n",
                 file, line, cudaGetErrorString( err ) );
        exit( -1 );
    }
    // More careful checking. However, this will affect performance.
    // Comment away if needed.
    err = cudaDeviceSynchronize();
    if( cudaSuccess != err )
    {
        fprintf( stderr, "cudaCheckError() with sync failed at %s:%i : %s\n",
                 file, line, cudaGetErrorString( err ) );
        exit( -1 );
    }
}


int main(int argc, char **argv) {
    std::cout << "Entered main!" << std::endl;

    // Inputs
    constexpr int TOTAL_ELEMENTS_IMG = B*IMG_D*D;
    constexpr int TOTAL_UNIQUE_ELEMENTS_IMG = IMG_D*D;
    float *img   = new float[TOTAL_UNIQUE_ELEMENTS_IMG];

    // Learned Parameters
    constexpr int TOTAL_ELEMENTS_IMG_MOD = B*D;
    float *img_mod_scale   = new float[TOTAL_ELEMENTS_IMG_MOD];
    float *img_mod_shift   = new float[TOTAL_ELEMENTS_IMG_MOD];
    bf16 *img_mod_scale_bf = new bf16[TOTAL_ELEMENTS_IMG_MOD];
    bf16 *img_mod_shift_bf = new bf16[TOTAL_ELEMENTS_IMG_MOD];

    // Intermediate outputs
    constexpr int TOTAL_ELEMENTS_O = B*IMG_D*D;
    constexpr int TOTAL_UNIQUE_ELEMENTS_O = IMG_D*D;
    float *o_ref  = new float[TOTAL_UNIQUE_ELEMENTS_O];
    bf16 *o_bf    = new bf16[TOTAL_ELEMENTS_O];
    float *o      = new float[TOTAL_ELEMENTS_O];

    if(argc > 1) {
        std::ifstream infile(argv[1]);

        printf("Loading from %s\n", argv[1]);
        std::cout << "Starting to enter!" << std::endl;

        // Inputs
        for(int i = 0; i < TOTAL_UNIQUE_ELEMENTS_IMG; i++) {  
            infile >> img[i];   
            if (i < 3) { 
                std::cout << img[i] << std::endl;
            } 
        }
        std::cout << "Finished loading IMG" << std::endl;

        // Intermediate Outputs
        for(int i = 0; i < TOTAL_UNIQUE_ELEMENTS_O; i++) {  infile >> o_ref[i];  }
        std::cout << "Finished loading O_REF" << std::endl;

        // Parameters
        for(int i = 0; i < TOTAL_ELEMENTS_IMG_MOD; i++) {  
            infile >> img_mod_shift[i];  
            if (i < 3) { 
                std::cout << img_mod_shift[i] << std::endl;
            } 
        }
        std::cout << "Finished loading IMG_SHIFT" << std::endl;
        for(int i = 0; i < TOTAL_ELEMENTS_IMG_MOD; i++) {  
            infile >> img_mod_scale[i]; 
            if (i == 0) { 
                std::cout << img_mod_scale[i] << std::endl;
            }   
        }
        std::cout << "Finished loading IMG_SCALE" << std::endl;

        std::cout << "Finished loading file from " << argv[1] << "!" << std::endl;
    }

    // Kernel inputs
    bf16 *img_bf   = new bf16[TOTAL_ELEMENTS_IMG];
    for(int i = 0; i < TOTAL_UNIQUE_ELEMENTS_IMG; i++) {
        img_bf[i] = __float2bfloat16(img[i % TOTAL_UNIQUE_ELEMENTS_IMG]);
    }
    bf16 *d_img;
    cudaMalloc(&d_img, TOTAL_ELEMENTS_IMG * sizeof(bf16));
    cudaMemcpy(d_img, img_bf, TOTAL_ELEMENTS_IMG * sizeof(bf16), cudaMemcpyHostToDevice);

    // Intermediate Outputs
    bf16 *d_o;
    cudaMalloc(&d_o, TOTAL_ELEMENTS_O * sizeof(bf16));

    // Parameter inputs
    for(int i = 0; i < TOTAL_ELEMENTS_IMG_MOD; i++) {
        img_mod_scale_bf[i] = __float2bfloat16(img_mod_scale[i]);
    }
    for(int i = 0; i < TOTAL_ELEMENTS_IMG_MOD; i++) {
        img_mod_shift_bf[i] = __float2bfloat16(img_mod_shift[i]);
    }
    bf16 *d_img_mod_scale, *d_img_mod_shift;
    cudaMalloc(&d_img_mod_scale, TOTAL_ELEMENTS_IMG_MOD * sizeof(bf16));
    cudaMalloc(&d_img_mod_shift, TOTAL_ELEMENTS_IMG_MOD * sizeof(bf16));
    cudaMemcpy(d_img_mod_scale, img_mod_scale_bf, TOTAL_ELEMENTS_IMG_MOD * sizeof(bf16), cudaMemcpyHostToDevice);
    cudaMemcpy(d_img_mod_shift, img_mod_shift_bf, TOTAL_ELEMENTS_IMG_MOD * sizeof(bf16), cudaMemcpyHostToDevice);

    // kernel: layernorm
    cudaDeviceSynchronize();
    CudaCheckError();
    unsigned long mem_size = 155480; // have the flag tell us
    std::cout << "Setting max block shared memory to " << mem_size << std::endl;
    using T = kittens::bf16;
    cudaFuncSetAttribute(
        flux_prepare,
        cudaFuncAttributeMaxDynamicSharedMemorySize,
        mem_size
    );
    cudaDeviceSynchronize();
    CudaCheckError();
    std::cout << "Starting kernel\n";
    const auto start = std::chrono::high_resolution_clock::now();
    flux_prepare<<<B,NUM_THREADS_NORM,mem_size>>>(
        d_img, d_img_mod_shift, d_img_mod_scale, d_o
    );  
    cudaDeviceSynchronize();
    const auto finish = std::chrono::high_resolution_clock::now();
    CudaCheckError();
    std::cout << "Finished kernel\n";

    if (test_with_intermediates > 0) {
        printf("Checking intermediates!\n");

        // check correctness
        cudaMemcpy(o_bf, d_o, TOTAL_ELEMENTS_O * sizeof(bf16), cudaMemcpyDeviceToHost);
        for(int i = 0; i < TOTAL_ELEMENTS_O; i++) { o[i] = __bfloat162float(o_bf[i]); }
        bool good = true;
        std::ofstream o_ref_file("printouts/o_ref.txt");
        std::ofstream o_file("printouts/o.txt");
        std::ofstream diff_file("printouts/diff.txt");
        for(int i = 0; i < TOTAL_ELEMENTS_O; i++) {
            float diff = o[i] - o_ref[i % TOTAL_UNIQUE_ELEMENTS_O];
            if(i < 1000) {
                o_ref_file << o_ref[i % TOTAL_UNIQUE_ELEMENTS_O] << ' ';
                o_file << o[i] << ' ';
                diff_file << diff << ' ';
            }
            if(abs(diff) > 0.2 || isnan(diff)) {
                good = false;
            }
        }
        if(good) std::cout << "Correct out :)\n";
        else std::cout << "Incorrect out :(\n";
    }

    // std::cout << "" << std::endl;
    std::cout << "Average execution time: " << std::chrono::duration_cast<std::chrono::microseconds>(finish - start).count() << " us" << std::endl;

    cudaFree(d_img);
    cudaFree(d_img_mod_scale);
    cudaFree(d_img_mod_shift);
    cudaFree(d_o);

    delete[] img;
    delete[] o, o_ref, o_bf;
    delete[] img_mod_scale, img_mod_scale_bf, img_mod_shift, img_mod_shift_bf;
    return 0;
}

